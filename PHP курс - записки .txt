ЛЕКЦИЯ I - Въведение в РНР http://www.youtube.com/watch?v=E9-l6Mbx-Vs&feature=youtu.be
http://bg.wikipedia.org/wiki/%D0%94%D0%B5%D0%BD%D0%B8%D1%81_%D0%A0%D0%B8%D1%87%D0%B8
Стринговете в PHP ЗАДЪЛЖИТЕЛНО трябва да са в кавички.
<?php

echo "Hello, \"PHP\"!";
#символът \ се нарича escape character.

?>
Чрез unset(); можем да изтрием дадена променлива или масив.


Масив, чийто ключове започват от 0 и следват до края без пропуск се наричат списъци.
Асоциативният масив е масив, чийто ключ е низ.

PHP не е чувствителен към новите редове, а към ; след функцията. С ; завършваме смислов ред.
Просто кодът няма да е форматиран правилно, ако използваме прекалено много нови редове.
Ако искаме да правим конкантенация използваме точка.
00:48:00 - String Builders и защо ги няма в PHP
00:53:00 - променливите се променят (в случая стрингове).

$_SERVER['HTTP_USER_AGENT'] - get browser properties.

!! PHP е динамичен език, в него няма типове данни.

Използваме за нов ред \n когато нямаме в стринга HTML и <br/> когато имаме.

В имената на променливите не можем да имаме интервали и специални символи. Не могат да започват с цифра.

var_dump - показва типа на променливата, от колко символа е и я извежда без да я обхожда. Не трябва да остава в production.
Променливите, които са нецели чилса, са от тип float. Тези ,които са цели числа - integer. Boolean са тези със стойност TRUE или FALSE.

Type casting - смяна на типа на променливата.
Когато пишем на PHP е правилно енкодингът да е на UTF-8.

Неинициализираните променливи имат NULL като стойност по подразбиране.

След var_dump не се пише =. Допустимо е да се използва само при разработка.
Когато задаваме float променлива, слагаме точка между цялото число и десетичните.
1:13:00 - масиви
ключовете на масивите могат да бъдат и стрингове.
���������
В РНР масивът може да съдържа масив.

if(){} else {} - структурата на if/else конструкта (това е тип условен оператор).
PHP allows you to send emails directly from a script

PHP не е case sensitive
AND = &&
|| = или
два пъти равно - "ако е равно"
три пъти равно - "щом са еднакви"; не е добра практика, защото изисква да се съобразяваме с типовете
!= обръща булевата стойност
$var =1; - променлива тип integer
$var ='1'; - string
Логически оператори - !, !=, AND, &&, ||, or, xor

Camel Case - първата буква е малка на първата дума, 
всяка следваща започва с голяма. Няма растояния или долни черти между думите. Прието е в Java Script и РНР.
Когато поставим @ пред фунцкия, от която PHP извежда error, PHP спира да извежда сигнала за грешка.

Функции с масиви - http://nau4i.me/jupgrade/index.php/php2/8-php--/76-2009-11-30-14-22-58

count($array) - взима броя на записите в даден масив. Ако зададем string, връща 1.
is_array($array) - проверява дали дадена променлива е масив. Връща true или false. Хубаво е да я използваме преди да използваме count().
Функции за сортиране елементите на масиви:

Тези фунцкии действат само за едномерни масиви:
ksort() - сортира елементите по възходящите стойности на ключовете.
krsort() - сортира елементите по низходящите стойности на ключовете.
sort() - сортира стойносите, но ключовете се губят, задават се нови, като започват от нула
rsort() - същото като sort(), но в низходящ ред
asort() - сортиране на масив във възходящ ред, като ключовете биват запазени, както и стойносите към тях.
arsort() - същото като asort(), но в низходящ ред.

array_multisort() - служи за сортиране на многомерни масиви.

if (isset($array[1])) () - проверява дали ключът на даден масив съществува.

if (array_key_exists(3, $array)) {} - проверява дали ключът на даден масив съществува. Работи само за едномерни масиви.

Търсене на стойност в даден масив: 

if (array_search($needle, $haystack)) {} - търси дадена стойност ($needle) в определен масив ($haystack). Може да не сработи, ако стойността има ключ, равен на нула. (14:30)

16:00 Toва може да се поправи по следния начин: 

if (array_search("b", $array)!==false) {} 

http://us3.php.net/manual/en/book.array.php

shuffle ();

array_push() - добавя елемент в края на масива.

array_slice(); - извлича част от масива

ЛЕКЦИЯ II - Въведение в PHP - втора част http://www.youtube.com/watch?v=QcdpqizH70w&feature=c4-overview&list=UULC-vbm7OWvpbqzXaoAMGGw

Всеки език си има приоритет на логическите оператори.
Ключът на даден масив не може да бъде число с плаваща запедая.

вж. arrays.php
<?php
phpinfo();
?>

Когато type cast-ваме от float към integer имаме загуба на информация, защото се губят символите след плаващата "запетая".
Когато type cast-ваме от string към boolean, PHP ще изведе true, освен ако стрингът не се състои само от 0 - '0'.
Когато type cast-ваме от string към integer, PHP извежда 0, дори и променливата да започва с цифра/и.
Когато type cast-ваме от string, който започва с число с десетична запетая и продължава с букви, PHP ще изведе числото.

$i++ - това се нарича инкрементиране

При цикъла for променливата може да се декларира и в цикъла, и преди това.

Използването на exit и die не е добра практика при завършването на цикли.
break - прикратява изпълението на цикъла и РНР обхожда кодът след затварящата скоба. Използва се само за изход на цикли!
//count — Count all elements in an array, or something in an object
//continue - прескача една итерация
http://nau4i.me/jupgrade/index.php/mysql/87-mysql-select--2
% - смислов оператор, който проверява дали стойността на променливата се дели на дадено число.

1:13:00 - функции
function ime($parametyr1, $parametyr2) {

}http://nau4i.me/jupgrade/index.php/mysql/87-mysql-select--2

hardcoding - записването на абсолютни стойности вътре в кодът 1:14:00
Предаване по референция.
PHP функции

echo 1, 2, 3;
е същото като
echo '1' . '2'. '3';

Функциите могат да поемат параметри

Ето целият условен оператор когато използваме die:

$connection = new mysqli ('localhost', 'Cvetomird91', 'iwillsucceed', 'gallery') or die ('no database');
Може и да се използва or, вместо else.


Създаване на адресна книга - http://www.youtube.com/watch?v=sEqtI82YF8o&feature=c4-overview&list=UULC-vbm7OWvpbqzXaoAMGGw

& - референция
Лоша практика:

$foo = 1;
$bar = 2;
$myArray = array (&$foo, &$bar);
Когато зададем параметър на функция, PHP я задава автоматично по референция, без да сме го задали по този начин.

Функции за включване на файлове:

include 'index.php'; - при изпълняването му, ако ако файлът отсъства PHP извежда error, но продължава с изпълняването на файлът.
include_once 'index.php';http://nau4i.me/jupgrade/index.php/php2/11-2009-12-02-13-53-20/106-1
require 'index.php'; - при използването му, ако файлът отсъства PHP вдига fatal error
require_once 'index.php';

echo '<pre>'.print_r ($_POST, true).'</pre>'; - важно е да сложим true тук
$username=str_replace ('!', ' ', $username);

floatval

ЛЕКЦИЯ III - Работа със сесии и файлове: http://www.youtube.com/watch?v=WRJE-Ua1dYQ&list=WL860FA23F1751764B


как да работим с MySQL и PHPmyadmin.
session_start(); винаги се пише най в началото, дори и преди <!DOCTYPE html>! Иначе можем да получим error. Ако искаме да прoменим името на
сесията със session_name();, трябва да го направим преди session_start();. Ако не искаме всеки път да задаваме особеностите на сесиите,
можем да променим зададените по подразбиране за тях настройки в php.ini.

session_set_coockie_params(3600); - задава животът на бисквитката в секунди.
http://www.php.net/manual/en/book.session.php - действия със сесии.


Unix time stamp - броя секунди от 1970 1 януари до сега - time ();
49:00 - fopen
54:00 - fclose - функции за работа с файлове.
feof(); - file end of file
DIRECTORY_SEPARATOR - 1:00:00
PHP_EON - константа за нов ред (1:02:00)
1:06:00 - realpath() - извежда целият път към дадена директория
is_dir - връща true или false. Показва дали даден стринг е директория. 1:12:00

1:13:00 - scandir - изброява файловете в определена директория.
$files = file('../data.txt'); - директория нагоре - ../
1:24:00 - input type="file"
Когато искаме да качваме файлове, методът на формата е POST и добавяме атрибута enctype="multipart/form-data"
$_FILES - глобален масив от типа на $_POST и $_GET и $_SESSION

move_uploaded_file($_FILES['picture']['tmp_name'], 'test php'. DIRECTORY_SEPARATOR. $_FILES['picture']['name'])
1:35:40 - request headers
cookie - информация, която даден домейн записва в нашия браузър
чрез сесиите запаметяваме информация за потребителя чрез cookie
$_SESSION

1:41:50 - работа със сесии
Не може да има бисквитка с два еднакви ключа.
1:48:00 - 'header already sent' error
С header функцията нагласяме header-ите на страницата.
session_destroy(); - 2:00:00

с move_uploaded_file PHP премества И замества файлът, ако има там такъв с същото име, но няма да изведе известие преди да го презапише.

сесиите са много пряко свързани с cookie-тата. Тя слага бисквитка на нашия компютър, която има уникален идентификатор.

Когато пишем header('Location: file.php'); е хувабо веднага след това да напишем exit;
nau4i.me - Лекции за създаването на галерия - http://nau4i.me/jupgrade/index.php/php2/11-2009-12-02-13-53-20/106-1

2:08:00 - как да нагласим лимитът на големина на файловете(по принцип е 8MB).

В домашната HomeworkSessionsAndFiles потребителят е успял да нагласи header-ите така, че при кликване на линка да му се сваля файлът.

Допълнителни материали за файлове и сесии http://www.youtube.com/watch?v=0nZedDo20FE&feature=youtu.be

в Windows за начало на реда се пишат \n\r, a в Linux само \n.

ЛЕКЦИЯ IV - Работа с MySQL - http://www.youtube.com/watch?v=nPsNRLJJlzY

00:44 - user_id в случая може да го зададем като NULL или въобще да не го въвеждаме.
Auto Increment - автоматично повишаване.

00:55 - как да export-ваме базата данни като файл.
Правилно е да вземаме данните в SQL формат, понеже в други формати ще е доста трудно да я прочетем отново с PHPMyAdmin.
Backup, dump и export са синоними в случая.
Понеже SQL е само текст, е препоръчително да export-ираме базите данни като zip, за да е по-малък размера на файла.
Възможно е да се export-не само структурата на базата данни без вече записаните полета в таблиците - това е препоръчително за домашната
работа, за да няма излишни вече запълнени полета.

Вместо if ($_POST) {} можем и да напишем if (isset($_POST['submit'])) {}

1:36:00 - MySQL не подържа булев тип данни. Вместо това типа данни се наглася на TINYINT, което заема по един байт информация.
След това в колоната Default нагласяме на As defined и 0 - т.е. по подразбиране потребителя е неактивен.

ORDER BY трябва да бъде последно. Единственото нещо, което трябва да е след него е LIMIT. С LIMIT задаваме от кой до кой резултат да изведе PHP. - LIMIT 0, 10
LIMIT е нещо специфично за MySQL - няма го в Oracle и MS SQL
ment using the LAST_INSERT_ID() function will also modify the value returned by the mysqli_insert_id() function.
1:44:00 - сортиране на данни.

1:47:00 mysqli_insert_id($connection);

1:51:00 Особеност на MySQL е когато дадено INT поле е с auto increment, той задава автоматично следващата стойност след най-голямата
зададена до сега, дори и да е зададена ръчно.

1:56:00 - как да ъпдейтваме таблиците с UPDATE.


1:58:00 Aко имаме правилни Foreign Key и Primary Key индекси, MySQL не би ни позволило да направим запис с несъществуващо id.

Break не може да се използва за изскачане от if statement, а само за излизане от масиви - while, foreach, for и т.н.

2:03:00 - Книги от автор

2:09:00 - Kниги от много автори

MongoDB - MongoDB (from "humongous") is an open-source document database, and the leading NoSQL database.

http://en.wikipedia.org/wiki/Object-relational_mapping

не може да има две бази данни с едно и също име.
Collation - на какъв encoding ще ни работи базата данни.
utf8_general_ci - тук ci означава "case insensitive"

performance_scema, information_scema и phpmyadmin не бива да се трият, понеже са служебни бази данни.
типовете данни в MySQL - INT (цифри), VARCHAR (използва се за малки текстчета), TEXT (за по-обемни текстове), DATA.
Когато използваме VARCHAR, задължително задаваме дължина на полето.
Когато събираме потребителски имена е непрепоръчително да използваме TEXT, защото заема много място.

Query-тата в MySQL започват с DELETE, SELECT, UPDATE или INSERT.  И при четирите ключови думи трябва да използваме FROM, за да кажем коя е таблицата.
Primary Key auto increment(A_I полето) - работи само когато полето е числово (INT). Автоматично задава пореден номер на клетката.

С Drop от падащото меню трием дадена база данни.
Има два основни енджина при работа със MySQL - MyISAMY и InnoDB.

Правилно е да се използват функциите за връзка с база данни, които започват с mysqli, вместо тези с mysql, които са deprecated.

Няма значение дали командите в MySQL са с малки или големи букви, но е прието да се пишат само с големи.

С TRUNCATE изтриваме съдържанието на таблица без да я унищожаваме. Това става с empty в MySQL.


$mysqli_error ($connection) - пише се само в процеса на разработка, за да може по-лесно да си видим грешките
mysqli_affected_rows($connection) - показва последно засегнатите клетки от таблицата от последното mysqli_query

PHPMyAdmin Export && Import http://www.youtube.com/watch?v=BWk_p2AzsPQ&feature=youtu.be

Галерия - първа част - http://nau4i.me/jupgrade/index.php/php2/11-2009-12-02-13-53-20/106-1

Името на дадена база данни се променя от Operations.

Mysqli - базово използване I http://www.youtube.com/watch?v=aENYuNC5ZDo

mysqli_connect ('host', 'username', 'password', 'table') - задава към коя база данни и таблица РНР ще запише данните.
последните две опции като port-a, на който работи MySQL и socket-a са опционални и за това не съм ги добавил тук.

mysqli_real_escape_string($connection, $_POST['username']) - използва се против MySQL инжекции. По-ефективно е от addslashes.

Mysqli - базово използване II http://www.youtube.com/watch?v=zZHHZU7ymXo - работа с prepared statements

Place holder. Питанката обозначава място, където ще има смяна на данни.
При работа с prepared statements не се използват mysqli_real_escape_string, понеже е невъзможно тогава да стане MySQL injection.

Примери за prepared statements.
$stmt=mysqli_prepare ($connection, 'SELECT * FROM user WHERE user_name=? AND password=?');
mysqli_stmt_bind_param($stmt, 'ssi', $_POST['username'], $_POST['password'], $_POST['age']); - има три параметъра
третият параметър са всичките данни, които ще бъдат заменени в $stmt. Колкото place holder-и имаме, толкова
са данните в третата стойност. Тези стойности трябва да бъдат променливи. Ако са hardcode-нати стойности,
РНР ще изведе error. Във втория параметър описваме типовете данни, които ще бъдат подадени към MySQL, например
'ssi' в случая(string, string, integer).

i	corresponding variable has type integer
d	corresponding variable has type double
s	corresponding variable has type string
b	corresponding variable is a blob and will be sent in packets

Информацията от Prepared Statement се взима с bind-ване на резултати:

mysqli_stmt_bind_result($stmt, $user_id);
mysqli_stmt_fetch($user_id);

MYSQLI_NUM is a constant in PHP associated with a mysqli_result.
If you're using mysqli to retrieve information from the database, MYSQLI_NUM can be used to specify the return format of the data.

mysqli_fetch_assoc() прави комбинация между mysqli_fetch_row() и mysqli_fetch_array().
mysqli_fetch_object() връща клас.

Индекси и JOIN в MySQL http://www.youtube.com/watch?v=i5jMBcRrv7w&feature=youtu.be

0:05:20 - какво представляват INDEX-ите в MySQL.
INDEX-ите са механизъм в базите данни за ускорено търсене.

MySQL ще използва ИНДЕКС, когато в таблицата имаме над 33% уникални записи. Това се получава когато
разделим 100 на броят на уникалните записи. (вж. Cardinality).

00:12:20 - PRIMARY index.
Primary key е направен да работи с енджини като InnoDB. Използването на Unique е доста близко до Primary.
Unique се използва когато не искаме да има два еднакви записа в таблицата.

00:19:00 - EXPLAIN

В MySQL в една и съща база данни можем да имаме таблици с различни енджини.

"bottleneck" - място, от където информацията в проекта излиза трудно.

SUN Microsystems - създателите на MySQL и Java.

Чрез JOIN(LEFT, INNER и RIGHT) можем да обединяваме таблици.
С INNER JOIN извеждаме таблици, при които и от двете страни имаме съвпадения.

MySQL уроци @ nau4i.me - http://nau4i.me/jupgrade/index.php/mysql

РЕлационните бази данни ни позволяват да запишем дадена информация в таблици, които да са свързани една с друга.

Разлика в SQL и MySQL - SQL се нарича езикът, чрез който се подрежда информацията в базата данни (MySQL, Oracle MS SQL и т.н.).
Базата данни е групиране на свързана информация.

С PHP плъгинът TCPFG можем да създаваме PDF файлове от MySQL резултати:
http://nau4i.me/forum/index.php/topic,15642.0.html

00:50 - JOIN

Когато export-ваме sql файл, в него се запаметява само самата структура на базата данни и таблиците. Записите в тях
не се запазват. Лоша практика е да се пробва да се експортват и записите в sql-a.

http://en.wikipedia.org/wiki/Object-relational_mapping

NetBeans - http://www.youtube.com/watch?v=Mp4g0EMB2_g

05:00 - Team --> Version control - помага за следенето на версиите на нашите проекти.
когато натиснем Ctrl+Space и NetBeans не може да изведе повече от един вариант за дописването на метода, той направо
дописва единствената останала възможност.

class ${file} {
//взима името на даден файл и го прави името на клас
}

Ако напишем само JOIN в MySQL query-то (без да задаваме LEFT или RIGHT) ще се изпълни INNER JOIN

при задаването на alias-ите не е задължително да се пише AS, но е по-нагледно.

Със метода session_set_cookie_params (3600,'/', 'localhost', false, true); настройваме особеностите на бисквитката.
Използваме го преди session_start();. Четирите параметра са животът на сесията в секунди, пътят на бисквитката (оставя се
'/'), домейнът на бисквитката, дали тя е secure (в случая е false, ако беше true бисквитката щеше да се прехвърли само, ако
потребителят беше влезнал през https, a не през http), петият параметър показва дали бисквитката е http only. Ако е false,
бисквитката може да бъде взета от JavaScript и да се получи session highjacking.

1:52:00 - агрегатни функции

http://www.youtube.com/watch?v=e8oNgrsmaY4&feature=youtu.be

00:33:00 - друг начин да направим проверка дали записът вече съществува в базата данни:

If (mysqli_num_rows ($q) > 0 ) {
	echo 'Има вече такъв запис';
} еlse {
	mysqli_query ($connection, 'INSERT INTO users (user_name) VALUES "'.mysqli_real_escape_string($db, $username).'"');
}

00:58
за да предаде HTML кодът multiple заявка от select полето към сървъра, трябва да добавим в името на полето фигурно скоби
например:
name="authors[]"

Взимането на информацията трябва да бъде независимо от визуализацията на информацията, т.е. източникът на информацията трябва
да е независим от този, който ползва информацията.

В php.ini като променим output buffering-ът задаваме колко байта може да задържи буферът преди да се изпразни.
Грешка при използване на процедурен код е смесването на информация и визуализация.

Когато поверяваме дали дадена променлива е с boolean стойност, се използва ===, за да проверим дали тя е от типа данни boolean.

По-правилно е да се използва mb_strlen, отколкото strlen.


$id = $_POST['value'];
$id = (int) $id; - cast-ване на дадена стойност към определен тип данни.

1:29:00 - Dependency injection, global $variable(ползва се например, за да направим променлива, чиято стойност сме задали в например if/else
конструкция и чрез global я правим с глобална видимост(scope).

Solid - серия от пет правила в програмирането:
http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)

1:34:00 - throw new exception

1:27:00 function authorExists ();

https://phpbestpractices.org/

http://net.tutsplus.com/tutorials/php/why-youre-a-bad-php-programmer/

Лекция 8 - http://www.youtube.com/watch?v=Ad_cPpNN2pE&feature=youtu.be

00:00:00 - I част - password security
00:54:00 - II част - Views
01:44:00 - лейаути

Важен принцип - разделяне на данните от презентацията на проекта.
Грешно е паролата да се запазва в plain text без значение от езика на програмиране и на базата данни.
00:04:30 - hash

RSS feed-ът е XML.
Khan academy RSA. RSA e един от основните криптиращи алгоритми.

Освен md5, можем да използваме и sha1.
00:12:00 - "солене" на паролите.

еcho md5(md5($username).$password); - salt

00:30:00 - PHP crypt
password_hash(); - използва се от PHP 5.5.0 нагоре

00:31:50 - oще един начин за password hesh
https://github.com/ircmaxell/PHP-PasswordLib - библиотека за криптиране на пароли

В бизнес частта на проекта ни не трябва да има HTML, CSS и Java Script.

От гледна точка на сигурността е хубаво всички файлове от проекта, освен index-a, да не са видими от Apache, а да се
взимат от други директории.

Преди да изпратим дадена домашна, трябва в sql файла да променим освен CREATE TABLE `books` и
USE `books`.

Функции в PHP (nau4i.me) - http://nau4i.me/jupgrade/index.php/php2/8-php--/63---php

Правилата за задаване имената на функциите са еднакви като тези за задаване имената на променливите.

Можем да изпълним дадена функция преди мястото, където сме я задали в кодът.

Когато при задаване на функцията зададем една от стойностите по подразбиране, когато я използваме,
незададените параметри ще бъдат тези по подразбиране (13:00).
Редът, по който задаваме стойностите на параметрите, е същият който сме изпозвали за задаването
на параметрите на функцията.

Не е добра практика да използваме над 8 параметъра за функция.

Single entry point - мястото в даден език за програмиране, от където започва целия процес. В PHP го няма.

Когато използваме дадена функция, трябва да задаваме стойностите на параметрите на функцията, по реда на
тяхното обособяване. Например, ако на първата стойност сме задали стойност по подразбиране, когато
извикваме функцията и зададем само една стойност (само за втория параметър), РНР ще изведе error.

Можем да накараме дадена функция да "връща" резултат с return. return прекратява изпълнението на функцията.

Затова в фигурните скоби след return; не трябва да има нищо.

Функцията break се използва само за изход от масив.

Алгоритъм за работа с VIEWS:
-във папката templates ще сложим .php файловете, които съдържат HTML код.
-във тези файлове не трябва да има бизнес логика(извличане на данни от MySQL например).
-1:10:00 - този начин на include-ване:
include 'includes/header.php'; е неправилен
-view-тата се викат накрая.

Лекция 9 http://www.youtube.com/watch?v=rrpoH7PECCY&feature=youtu.be

00:03:00 - определение за процедурно програмиране

обектите енкапсолират в себе си информация

00:04:00 - определение за ООП

klasovete se zadavat po sledniq na4in:

class Username {

  public $username;
  public $age;
}

няма скоби след името на класа.
Важно е да разберем разликата мейду клас и инстанция.
Класът е изходния код. Не можем да използваме класовете директно. Трябва да създадем инстанция.
Инстанциите се задават с new.
например

$user = new User();
$user -> age = 18;

00:22:15 - $this в функции.
$this - означава "тази инстанция".

Добра практика е един клас да се намира в един файл, който носи неговото име.
Лоша практика е в един файл да имаме повече от един клас.

00:29:40 какво представлява public, private и protected.

свойствата, които са private не могат да бъдат променяни отвън класа.
Лоша практика е свойствата да са публични.

В момента всички известни PHP проекти са написани в ООП стил.

00:37:00 - практика как да си защитим свойствата чрез функции (set, get).

00:37:40 - не е задължително да се задава видимост на свойствата.
Ако не я зададем по подразбиране е public.

00:40:30 - конструктори
РНР извиква автоматично конструкторите, когато зададем нова инстанция.

public function __construct ($age, $username) {
	$this -> age = $age;
	$this -> username = $username;
}

При конструкторите не действа return! Те не връщат стойност. По подразбиране връщат $this.

00:45:30
един друг начин да зададем конструкт, останал от PHP 4:

public function User() {
	echo 'Init';
}

където името на функцията е същото като името на класа. Това не е добра практика.

Имената на магическите методи започват с две долни черти.

Linux е case sensitive OS, докато Windows не е.

Деструкторът се извиква, когато обектът изчезва.

01:05:00:
към 66-68 ред:
// тук дефинирахме стойността на свойство, което не фигурира в класа User. Това не е добра практика. За да я
// избегнем използваме магическата функция __set. Единствено в РНР е възможно подобно нарушение на обектния модел.

Когато има равно предаваме стойност на даден параметър, а когато няма - взимаме.

Прието е когато имаме private или protected функция, името й да започва с долна черта.

Когато натиснем Alt+insert в NetBeans излиза меню, с което можем да настроим кои функции служат за нагласянето на данни и кои за извличането им (get и set).

Добра практика е класът да носи името на файла.
1:30:00 - унаследяване на класове с extends

Когато дадено свойство е public, e видимо навсякъде в файла.
Когато е protected, се вижда от мястото, където е дефинирано, както и от класовете, които го унаследяват.
Свойствата, които са private, са видими само в класовете, в които са зададени.
Когато задаваме отново свойство в дъщерен клас, пренаписваме й видимостта му. (1:46:00)

Когато в дадена функция искаме да зададем

parent:: method(); - използване на функция от parental class.
PHP има вграден Garbage collector.

Основни поятия в ООП:
клас, обект, инстанция, абстракция, капсулиране, наследяване, метод, свойство, видимост

Не бива да задаваме глобални променливи когато задаваме класове - NB.

Когато сложим ключовата дума final преди индикатора за видимост на даден метод, тя не може да се презаписва.

употреба на магическия метод __set():

public function __set($name, $value) {
  echo $name . ': ' . $value . '<br/>';
}

Методът __set се употребява, когато се опитваме да зададем параметри на незададени в класа свойства.
Тогава параметърът $name се явява името на незададеното свойство, а $value - неговата стойност.

Свойството не бива динамично създадено вътре в обекта, когато мине през __set().
Заедно с магическия метод __get() те сформират шаблона registry.

Магическият метод __call($name, $arguments) се задава, за да може да се предпазим от използването на недифинирани
в класа методи, където $name е името на метода, а $arguments - неговите аргументи.

За да зададем статичен метод, трябва да напишем думата static преди индикатора за видимост на метода. Статичният метод не е обвързан с инстанция, той
е обвързан със съответния клас.

Обръщаме се към него с две двуеточия. Например:

ObjectName::StaticMethod();

Статичните методи не могат да използват ключовата дума $this.

Когато използваме статични свойства, трябва да напишем $:

ObejctName::$username;

Не можем да променяме статични свойства. Едно свойство става статично, когато добавим static преди индикатора за видимост.

Ключовата дума self се изпозлва за достъпването на статично свойство вътре в класа в обикновен метод.

public function setAge($age) {
  self::$age;
}

Другият начин е като използваме директно името на класа:

ObjectName::$age;

Статичните методи не са обвързани с никоя конкретна инстанция.

Лекция 10 - http://www.youtube.com/watch?v=b2XSPsF5A8s#t=441

Прието е имената на класовете да започват с главна буква.

Инстанция може да се зададе по двата начина:

$username = new User();

и

$username = new User;

Но е по-нагледно да поставим скоби.

00:07:20 - тук е разликата между обект и инстанция. $ivan и $petko са два различни обекта.

Можем да достъпваме static свойства, но само през името на класа.
Статичните методи и свойства се наричат статични, защото не са обвързани с нито една инстанция.

00:19:00 - Singleton

$connection = DB::newInstance();
$connection2 = DB::newInstance();

$connection == $connection2 в случая.

00:29:30 - шаблона Registry

Когато използваме регистри, не трябва да го използваме за основната информация на проекта. То се ползва за малка важна информация, която е глобална за
повече от един обект.

00:37:30 - интерфейси & задача за упражнение.

PHP библиотеки - http://tutorialzine.com/2013/02/24-cool-php-libraries-you-should-know-about/

00:40:00 - интерфейси

Фунцкиите в интерфейсите могат да бъдат само публични.

Интерфейсите служат за подписване на договори между създателя на даден продукт и потребителите, които дописват приложението,
ако е open source, например.

class Class implements TestInterface {
   publuc function fnc1() {

   }

   public function fnc2() {

   }
}

По този начин се имплементира интерфейс, където fnc1 и fnc2 са фунцкиите, зададени в TestInterface.

В Java има практика имената на интерфейсите да започват с I(малко или голямо).

Един обект трябва да се грижи за едно нещо.

01:04:00 instanceof




!!!!!Информация, която Гатака не е представил в двете лекции за OOП:

Магическия метод call: http://nau4i.me/jupgrade/index.php/php2/12-oop/265-call-9
Интерфейси в ООП - http://nau4i.me/jupgrade/index.php/php2/12-oop/269-12
Абстрактни класове - http://nau4i.me/jupgrade/index.php/php2/12-oop/271-php-oop-abstract-classes
Проверка на типовете обекти в ООП: http://nau4i.me/jupgrade/index.php/php2/12-oop/272-php-oop-objects-types
Документация на класове - http://nau4i.me/jupgrade/index.php/php2/12-oop/273-php-oop-documentation-methods-properties
Try Catch Throw - http://nau4i.me/jupgrade/index.php/php2/12-oop/281-php-oop-try-catch-throw
Type Hinting - http://nau4i.me/jupgrade/index.php/php2/12-oop/283-php-oop-type-hinting
Променливи променливи http://nau4i.me/jupgrade/index.php/php2/12-oop/285-php-oop-variable-variables
Namespaces - http://nau4i.me/jupgrade/index.php/php2/12-oop/282-php-oop-namespace

Магическия метод call: http://nau4i.me/jupgrade/index.php/php2/12-oop/265-call-9

Ключовата дума parent: http://nau4i.me/jupgrade/index.php/php2/12-oop/267-parent-11
parent::methodName(); - извиква метод от parental класа, който бива унаследяван.

В Java и .NET интерфейсите се ползват често, за разлика от PHP.
Можем да имплементираме повече от 1 интерфейс, като разделяме имената на отделните интерфейси със запетая.

class User implements iRegister, iCopyrights {
	//insert code here
	//PHP ще изкара грешка тук, щом не сме използвали задължително методи в имплементираните интерфейси.
}

Напълно възможно е даден клас да унаследява друг и същевременно да имплементира интерфейс(и), но в PHP това е
възможно, ако първо унаследява, а след това имплементира.

class User extends Register implements iRegister, iCopyrights {
	//insert code here
	//PHP ще изкара грешка тук, щом не сме използвали задължително методи в имплементираните интерфейси.
}

Абстрактни класове - http://nau4i.me/jupgrade/index.php/php2/12-oop/271-php-oop-abstract-classes

Абстраткните класове са подобни на интерфейсите.
Интерфейсът може да съдържа само "подписите" на методите.

Когато поставим abstract преди индикатора за видимост на даден метод, той става абстрактен, а класът, който го съдържа -
абстрактен клас. Също трябва да добавим ключовата дума аbstract пред class.
Не може да се направи инстанция на абстрактен клас!!!!

За да използваме функциите и свойствата на даден абстрактен клас, трябва да създадем клас, който го унаследява.

Абстрактните методи, унаследени от абстрактен метод, трябва да бъдат имплементирани в класа, който
който го унаследява, т.е. трябва да бъдат зададени там методи със същите имена.

Проверка на типовете обекти в ООП: http://nau4i.me/jupgrade/index.php/php2/12-oop/272-php-oop-objects-types

PHP Doc - програмата, която чете класовете и генерира техническата документация.

Коментарите, които са структурирани по следния начин:

/**
* Description of Doc
*
* @author Cvetomir Denchev
*/

се четат от този софтуер.

Документация на класове - http://nau4i.me/jupgrade/index.php/php2/12-oop/273-php-oop-documentation-methods-properties

В повечето среди за разработка, когато напишем /** и натиснем enter, автоматично IDE-то ще попълни за нас документацията на класа.
Рядко се случва да бъдат документирани свойствата в класа.

Try Catch Throw - http://nau4i.me/jupgrade/index.php/php2/12-oop/281-php-oop-try-catch-throw
exceptions

throw new Exception ($message, $code, $previous); вместо return false или return 'error message';
try catch throw се използва в другите езици за програмиране само в крайни случаи при фатална грешка, докато
в PHP се използва при всеки случай на извеждане на грешка - например ако потребителското име и парола са твърде кратки и т.н.
Прихващането на грешката става с try там, където извикваме кодът.
$exc
Можем да унаследяваме класа Exception.
Можем да си наредим цяла серия от catch механизми. Има значение подредбата на catch механизма.
Има значение подредбата на catch механизма.
Правилно е последния catch да е от клас Exception.


Advanced PHP Tutorial 3: Exception Handling - http://www.youtube.com/watch?v=sPHuhQOxisg
{$num}
02:30 Когато няма catch конструкция да "хване" exception-a, се получава fatal error.
Можем да кръстим променливата в catch (Exception $exc) както желаем, не е нужно да е $exc.

Type Hinting - http://nau4i.me/jupgrade/index.php/php2/12-oop/283-php-oop-type-hinting

Лимитиране на типовете обекти, които ще бъдат получавани като параметри.

function go (TestClass $obj) {
  var_dump ($obj);
}

class TestClass {


    public function __construct () {

    }
}

go (new TestClass());

Функцията go ще приеме само стойности, които са от типа TestClass. В други силно типизирани езици се пише типът данни на параметърът.

Променливи променливи http://nau4i.me/jupgrade/index.php/php2/12-oop/285-php-oop-variable-variables

Namespaces http://nau4i.me/jupgrade/index.php/php2/12-oop/282-php-oop-namespace
namespace Model; - така се задава namespace.

$variable = new Model\User();
Добра практика е namespace-a да носи името на директорията, в която се намира.
Namespace трябва да бъде първото нещо във файла. Над него може да има само коментари. Това е така, защото ако декларираме клас преди неймспейса, този namespace 
няма да отговаря за него.
Възможно е името на namespace да съдържа \. Задаването на неймспейсове от типа на namespace Model\User може да улесни структурирането на кода.
PHP поставя класовете без namespace в един глобален namespace.
Имената на неймспейсовете НЕ трябва да са РНР или да започват с PHP.
Имената на някои РНР фунцкии могат да започват с \. Така казваме на PHP, че търсим нещо в глобалния namespace.

Лекция 11 - http://www.youtube.com/watch?v=ir9ps5WgzUQ&feature=youtu.be

00:07:00 - работа с code igniter.
CodeIgniter работи с PHP 4.
CodeIgniter е вече остарял framework. Не бива да се ползва в production.
CodeIgniter e open source.
При CodeIgniter проектът се поставя в определена директория в CodeIgniter папката. При други шаблони, файловете на шаблона се include-ват в проекта.

MVC - Model Viel Controller
Model–view–controller (MVC) is a software architecture pattern which separates the representation of information from the user's interaction with it.[1][2] The model consists of application data, business rules, logic, and functions. A view can be any output representation of data, such as a chart or a diagram. Multiple views of the same data are possible, such as a bar chart for management and a tabular view for accountants. The controller mediates input, converting it to commands for the model or view.[3]
http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller

00:12:00 CodeIgniter има папки model, view и controller
Един от плюсовете на фреймуърците е, че когато искаме да добавим нова фунцкионалност трябва да създадем само нов клас.

00:22:40 - магическият метод _call().

РЕСТафарианци.


00:28:30 - обяснение за MVC.
MVC е един от най-използваните шаблони в програмирането въобще.

View-то е мястото, където информацията се визуализира.
Съществува практика view-тата да носят същото име като контролера.

00:50:00 - сесиите в CodeIgniter
random.org - сайт за произволни числа и низове.

При уботребата на бисквити в CodeIgniter всички данни, които слагаме се запазват в бисквитката на потребителя.
Ако искаме да работим с бисквитки в CodeIgniter, е хубаво да ги изнесем в база данни:
$confit = session['sess_use_database'] = true; (autoload.php)
IntelliSense на средите за разработка не работят при CodeIgniter.

01:04:00 - стойността null когато връщаме стойности.

01:19:30 - примерна message система с Code Igniter.

В PHP не можем да кръщаваме методи new, понеже това е ключова дума.

Code Igniter няма ORM.

01:39:00 - запазване на съобщение в MySQL

Code Igniter не поддържа prepared statements.

Моделите трябва да работят единствено и само с данни, които идват като параметри на тяхните методи. Не трябва да се използват суперглобални променливи.

Контролерът само взима данните и ги хвърля на view-то.

"твърди връзки"

Изпитът няма да включва Code Igniter. Изпитът ще е само върху материал, представян в рамките на лекцията.

PHP (Hyper PreProcessor) е динамичен C/C++ базиран скриптов сървървърен език със слаба типизация на променливите и силна подръжка на масиви.
Служи за изграждане на динамични уеб страници, уеб приложения и сайтова администрация,т.е. може да указва връзка с различни релационни бази данни с цел запазване на пароли
и данни за потребителите.

Инсталиране на нужния софтуер за Линукс: http://nau4i.me/jupgrade/index.php/php2/8-php--/49--ubuntu
NetBeans е написан на Java.

Правилно е файловете от Model/бизнес частта да са със затворен php таг.

MySQL уроци @ nau4i.me - http://nau4i.me/jupgrade/index.php/mysql/

Въведение в MySQL - http://nau4i.me/jupgrade/index.php/mysql/79-mysql-

MySQL Server е база данни. Базата данни е приложение, което позволява да записваме информация по определени правила.
MySQL е релационна база данни. Друг тип бази данни са обектните.
Релационните бази данни лежат върху математически модели.

04:30 - разлика между SQL и MySQL.
SQL (Structure queary language) - структуриран език за заявки. Toва е самият език, който определя начина на взимане на информация от релационните бази данни.
MySQL е сървърът(базата данни), който взима заявките, и ги изпълнява.
SQL е езикът, MySQL е сървърът, базата данни. M$ SQL, MySQL и Oracle работят по един и същи стандарт, но всеки си има свой диалект, свои особености в синтаксиса, специфични
за самия него.

Има MySQL база данни и MySQL сървър.
Един MySQL сървър може да има много бази данни. Можем да правим връзка между информацията само в таблиците на една база данни.
MySQL е бесплатна база данни.
M$ SQL е достъпна само под Windows.
Oracle е платен продукт.
Актуалната му версия е 5.6.14

PHPMyAdmin - http://nau4i.me/jupgrade/index.php/mysql/80-phpmyadmin-

DROP - изтриване
utf8 подържа всеки един език.
Хубаво е collation-a да е на utf8_general_ci. UTF-8 заема малко повече място като размер. ci - case insensitive. utf8_general_ci e encoding-ът, който се използва,
когато не сме задали кодиране на базата данни.
Имената на таблиците трябва да посочват каква информация съдържат в себе си.
Хубаво е имената на колоните в дадена таблица да имат еднакъв prefix.
Ако използваме Camel Case за кръщаване на имената на колоните (например userId, userName и т.н.), трябва когато пишем MySQL заявки в PHP кодът, също да спазваме Camel Case, понеже
Linux е Case Sensitive ОС, а Windows не е.


MySQL сървърът слуша за заявките, а storage egnine-ът е нещото, което физически изпълнява и обработва заявката.

Енджинът MyISAM е оптимизиран за работа със SELECT. Оптимизиран е за много бързи селекти.
Масово се използва когато имаме малко записи, но много четения. Подържа full text search.
В MyISAM няма transactions. Няма primary key, foreign key.

InnoDB е подходящо да се използва при направата на счетоводен софтуер и банков софтуер. Там има транзакции.
От Structure променяме съдържанията на таблиците.
Overhead - 30:30
With selected --> Optimize Table - така се оптимизира таблицата и се премахва Overhead-a.
Когато една таблица доста често се записва и изтрива се натрупва Overhead.

Съществува конвенция, която гласи, че полетата с primary key auto increment трябва да са първи в таблицата.

36:00 - създаването на нов потребител. Когато изберем хоста да е localhost, трябва заявката да идва от абсолютно същия компютър,
на който е инсталиран MySQL сървъра.

39:00 - еxport на база данни.
От Add Drop table database можем да зададем дали при Import-ване на базата данни на друг сървър да бъде презаписана вече съществуваща база данни със същото име.

PHPMyAdmin позволява да компресираме текста, за да заема по-малко място. При по-големи бази данни това е препоръчително.

Типове данни в MySQL - http://nau4i.me/jupgrade/index.php/mysql/81-mysql

integer типове данни и техните граници http://dev.mysql.com/doc/refman/5.0/en/integer-types.html

Под Линукс с PHPMyAdmin нова таблица се прави със SAVE (отляво :D).

Когато задаваме нова колона от INT тип от Attributes - Unsigned задаваме долната граница да е нула и да не са позволени отрицателни стойности.

11:00
По-големите числа заемат повече място. TINYINT заема 1 bite, SMALLINT - 2 байта, BIGINT - 8 байта, МEDIUMINT - 3, а
INT - 4 bites.
12:40 - Правило е да се използват най-малкия възможен тип данни.

DECIMAL, FLOAT, DOUBLE, REAL - четирите типа данни за работа с числа с плаваща запетая в MySQL. Тези неща са полезни когато изготвяме счетоводен софтуер.
DOUBLE поддържа двойно повече цифри след запетаята от DECIMAL. Правилото за Unsigned работи и за тези типове данни.

VARCHAR се различава от TEXT по това, че можем да зададем максималната дължина на данните от текстови тип.

Логично при тези типове данни Unsigned не играе роля, понеже това са текстове.
VARCHAR е за стойности от макс 200-300-500 символа.
Не можем да зададем максималната граница на TEXT. Има няколко подтипа.
25:30 - Null.
Празна стойност. От checkbox-a null задаваме дали може да има такава стойност на запис в таблицата.
Null работи по точно определени правила.
Default - стойност по подразбиране
31:20 Auto_increment - за да бъде A_I полето трябва да е числов тип (INT).
EMPTY изпразва информацията записана в таблицата, но не я изтрива.

37:50 - коментари

MySQL INSERT - http://nau4i.me/jupgrade/index.php/mysql/82-mysql-insert

05:30 въвеждане на данни с кавички в тях
С тези кавички може да се правят MySQL injections.
С PHP това се избягва с mysqli_real_escape_string, a ако въвеждаме данни "на ръка" - с escape character (\).
Когато въвеждаме числа може и да не ги поставяме в кавички.

MySQL DELETE - http://nau4i.me/jupgrade/index.php/mysql/84-mysql-delete
TRUNCATE TABLE `table name` - изтрива таблица
EMPTY TABLE `table name` - изтрива всички записи в таблицата.
DELETE FROM `users` WHERE user_id=5
DELETE FROM `users` WHERE user_id>1 AND user_id<10
AND и OR си работят по същия начин в МySQL като в програмните езици.

MySQL UPDATE - http://nau4i.me/jupgrade/index.php/mysql/83-mysql-update

Можем да използваме смисловите оператори за делимост в MySQL query-то:
UPDATE users SET user_gender="f" WHERE MOD (user_id,2) - така ще се UPDATE-нат редовете, чиито стойности на колоната 
user_id се делят на 2.

UPDATE users SET user_gender="f" WHERE MOD (user_id,2)=1 - така ще се UPDATE-нат нечетните стойности и т.н.

Може и да стане по слендия начин:

UPDATE users SET user_gender="m" WHERE user_id%2=1 - нечетни стойности
UPDATE users SET user_gender="m" WHERE user_id%2 - четни стойности.
Също, ако полето е за запазване на низове, трябва да поставим новата стойност след SET в кавички.

Можем да задаваме едни и същи полета след смисловите оператори SET и WHERE:

UPDATE users SET status=0 WHERE status=1

SELECT I част - http://nau4i.me/jupgrade/index.php/mysql/85-mysql-select--1

SELECT * FROM не е препоръчително да се ползва, понеже така пренатоварваме сървъра когато избираме всички колони от таблица.
З

Хубаво е да слагаме избраните таблици в `, в случай, че има запетайка в името на някоя от тях.
SELECT `login`, `age` FROM users 

SELECT COUNT (*) FROM `users` - извежда броят на редовете, който има дадена таблица.

SELECT *, COUNT (*) AS NumRows FROM `users` - резултатът ще изведе още една колона (NumRows), която ще е число, обозначаващо броят на редовете.
SELECT MAX (user_id) FROM users - като цяло се използва за цифрови стойности. При текстовете може и да сработи, като подрежда резултатите по азбучен ред.
SELECT MIN (user_id) FROM users - същото е валидно и за MIN.
И MIN, И МАХ могат да бъдат зададени като алиаси.

SELECT II част - http://nau4i.me/jupgrade/index.php/mysql/87-mysql-select--2

13:50 - LIMIT - задава PHPMyAdmin колко редове да показва на страница от резултата.
Например LIMIT 1,10 - показва 10 резултата, като започва от втория. Вторият параметър показва броя на резултатите, които искаме да бъдат изведени.

индекси - http://nau4i.me/jupgrade/index.php/mysql/88-mysql-
Основната цел на индексите е да подредят информацията в базата данни по точно определен начин, за да ускорят търсенето на данни в тази информация.
Индексите ускоряват този процес до 2000-3000 пъти в по-големи проекти.
  Недостатък е, че те заемат процесорно време.
Индексите по никакъв начин не променят информацията. Те заемат място. Индексите се записват на отделно място от MySQL.
Index 
Primary Key - използва се в InnoDB енджина. Подходящ е да се използва заедно с auto increment.
Unique - той не позволява едновременно да има два еднакви записа, което е подходящо наприме за запис на ЕГН, потребителско име и т.н.
Full text - специфичен е за MyISAM. Слага се само на текстови полета. 
Направен е за търсене в огромни количества текст. Подходящ е за форум, при търсене на резултати в постовете. Не е наличен за InnoDB.
PHPMyAdmin ще ни алармира, ако сме поставили два индекса на една колона. Това е непрактично.

No Index definied - така PHPMyAdmin ни алармира когато не сме задали индекс на таблица. 
Индексът се добавя към колона, а не цялата таблица.
Cardinality - показва силата на индекса.
Индексът може да бъде редактиран и да му се променят настройките.
MySQL използва само по един индекс според ситуацията. Има условия за използването на правилния индекс.
Редно е да поставяме индекс на поле, което използваме за SQL заявката, например user_id.
Data Integrity - http://hightechnology.in/what-is-data-integrity-in-sql-server-and-its-types/

Запис на йерархична информация в базата данни - http://nau4i.me/jupgrade/index.php/mysql/403-storehierarchicaldatainadatabase

Чиста релация
Agency list - недостатък е, че работи със SELF JOIN
10:00 - nested set model - http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/

PHP - Галерия

I част -

07:00 - обяснение на exit.

Тестове - записки 
Името на променлива не може да съдържа тире.
Според теста на W3Schools die () и exit () правят едно и също нещо.
IIS - Internet Information Server - сървъра на Windows, подобен на Apache.
PHP може да изпраща e-mail-и директно от скрипт.
What is the correct way to open the file "time.txt" as readable?fopen("time.txt","r");

array_count_values($array) връща масив със стойностите на $array като ключове и пътите, в които те се срещат като стойности.
Функцията mail() :
bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] );


MVC framework уроци

http://nau4i.me/jupgrade/index.php/php2/59-php-mvc-framework/359-php-mvc-framework-01: 
Моделът е частта от проекта, която се свързва с базата данни (или файл или уеб сървис), записва и модифицира информацията, валидизира я 

Моделът се грижи за валидация на данните, тяхната цялост, както и за извличането, добавянето и редакцията им. 
Държи абсолютно цялата логика на данните. (например колко може да е максималната дължина на потребителското име).
Може да извиква други модели.
НЕ може да вика view или контролер.
НЕ трябва да използва глобални променливи, а само параметри.
Когато даден модел е изпран от контролера, той взима данните, които трябва да вземе и ги връща обратно към контролера.

VIEW - грижи се за презентация на данните (най-често генерира HTML).
НЕ може да извиква модели и контролери. 
Може да извиква други изгледи.
Трябва да работи само с подадените данни от контролера.
Не трябва да работи с глобални променливи.

Controller - в зависимост от входящите параметри решава кои модели и кои изгледи трябва да се извикат, както и тяхната последователност.
Предава параметри на моделите, взима техните отговори, и ги предава на изгледа. Ако моделът върне грешка, трябва да може да обработи съответната ситуация.
Не може директно да вика други контролери, а трябва да използва вградения във фреймуърка механизъм.
Може да използва валидация на данни, но само ако тази валидация е пряко свързана с работата на контролера, а не на модела.

MVC framework #2 App класа - http://nau4i.me/jupgrade/index.php/php2/59-php-mvc-framework/360-php-mvc-framework-02-class-app

boostrap - единствения видим от сървъра файл в проекта. 
CSS и Java Script файловете трябва да са в неговата директория.
С класа App започва и стартира изпълнението на програмата.
класа App взима заявката, front controller, 